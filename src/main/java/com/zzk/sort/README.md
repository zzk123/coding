## 排序算法
### 选择排序
1.首先找到数组中最小的那个元素，其次将它和数组的第一个元素交换位置（如果第一个元素是最小元素那么它就和自己交换）。再次，在剩下的元素中找到最小
的元素，将它和数组的第二个元素交换位置，如此往复，直至将整个数组排序
2.用了N次交换 - 交换次数和数组的大小是线性关系
3.选择排序不是稳定算法，为原地排序，时间复杂度为 N^2，空间复杂度为 1，
 
### 插入排序（直接插入排序、折半插入排序）
1.排序算法所需的时间取决于输入中元素的初始顺序，例如，对一个很大且其中的元素已经有序（或接近有序）的数组进行排序将会对随机顺序的数组或者逆序数组进行
快得多
2.插入排序对于部分有序的数组十分高效，也是适合小规模数据
3. 直接插入排序是稳定算法。为原地排序。时间复杂度为 N~N^2（取决于元素初始顺序），空间复杂度为O(1)
   折半插入排序是稳定算法。为原地排序。时间复杂度为 Nlog2(N)~N^2（取决于元素初始顺序），空间复杂度为O(1)
4. 折半插入排序相比直接插入排序的优点在于减少了比较次数，折半插入排序比较的时间复杂度为 Nlog2(N)，直接插入排序比较的时间复杂度为 N~N^2

### 希尔排序
1. 思想：使数组中任意间隔为h的元素都是有序的；
   实现：对于每一个h，用插入排序将h个子数组独立地排序；
   高效的原因：权衡了子数组的规模和有序性
2. 希尔排序不是稳定排序，是原地排序，时间复杂度为 Nlog2(N) ~ N^r(1<r<2)，空间复杂度为O(1)

### 归并排序
1. 归并排序的优点在于能够保证将任意长度为N的数组排序所需的时间和NlogN成正比，他的主要缺点在于所需的额外空间复杂度和N成正比
2. 归并排序是稳定排序，不是原地排序，时间复杂度为 NlogN，空间复杂度为 O(N)

### 快速排序
1. 对于很小的数组（<=20），快速排序不如插入排序
2. 快速排序不是稳定排序，是原地排序，时间复杂度为 Nlog2(N)~N^2，空间复杂度为 log2(N)

### 堆排序
1. 堆排序是能够同时最优地利用空间和时间的方法，在最坏的情况它也能保证使用2Nlog2(N)次比较和恒定的额外空间
2. 堆排序不是稳定排序，是原地排序，时间复杂度为 NlogN，空间复杂度为 O(1)
3. 堆的应用：
   优先队列：一种抽象数据类型，优先队列中每个元素都有各自的优先级，优先级最高的元素最先得到服务。优先队列往往用堆来实现
   堆排序：利用堆来进行的一种排序方法
4. 堆排序的步骤（最小堆为例子）
   a、建立堆：按照元素关键字建立一个堆（最大堆/最小堆）
   b、删除最小值：让根节点归位（根据堆序性，根是最小元素）
   c、调整堆：重新调整使其继续保证堆的结构性和堆序性

### 冒泡排序
1. 冒泡排序是一种稳定的排序，时间复杂度为 N~N^2，空间复杂度为O(1)

### 基数排序
1. 基数排序非常适合用于整数排序，尤其是非负整数
2. 执行流程：依次对个位数、十位数、百位数、千位数、万位数。。。进行排序
3. 属于稳定排序，不是原地排序，最好、最坏、平均时间复杂度为:O(d*n)，空间复杂度是 O(n+k)，d是最大值的位数，k是进制

### 桶排序
1. 执行流程：
   a.创建一定数量的桶（比如用数组、链表作为桶）
   b.按照一定的规则（不同类型的数据，规则不同），将序列中的元素均匀分配到对应的桶
   c.分别对每个桶进行单独排序
   d.将所有非空桶的元素合并成有序序列
2. 是稳定排序算法，不是原地排序， 
   空间复杂度为 O(n+m)，m是桶的数量
   时间复杂度为 循环分配桶的时间：O(N) + 针对每个桶内元素排序时间：O(m * O(n/m * log2(n/m)))，得出 O(n + n * log2(n) - n * log2(m))，
   因此为 O(n+k)，k为 n*log2(n) - n*log2(m)
   

### 计数排序
1. 核心思想：统计每个整数在序列中出现的次数，进而推导出每个整数在有序序列中的索引
2. 适合在一定范围内的整数排序
3. 计数排序是稳定排序，不是原地排序，最好、最坏、平均时间复杂度为O(N+k)，空间复杂度为O(N+k)，k是整数的取值范围

### 注意
冒泡、插入、归并、快速、希尔、堆排序都是基于比较的排序，平均时间复杂度目前最低是 O(Nlog2(N))
计数排序、桶排序、基数排序都不是基于比较的排序，是典型的用空间换时间，在某些时候，平均时间复杂可以比O(Nlog2(N))更低