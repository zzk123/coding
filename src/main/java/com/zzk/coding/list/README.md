# 链表问题

## 1.打印两个有序链表的公共部分
### 题目：
给定两个有序链表的头指针head1和head2，打印两个链表的公共部分

## 2.在单链表和双链表中删除倒数第K个节点
### 题目：
分别实现两个函数，一个可以删除单链表中倒数第K个节点
### 要求：
如果链表长度为N，时间复杂度达到O(N)，额外空间复杂度达到O(1)

## 3.删除链表的中间节点和a/b处的节点
### 题目：
给定链表的头节点head，实现删除链表的中间节点函数
例如：
不删除任何节点
1->2，删除节点1;
1->2->3，删除节点2;
1->2->3->4，删除节点2;
1->2->3->4->5，删除节点3;

进阶：
给定链表的头节点head、整数a和b，实现删除位于a/b处节点的函数
例如：
链表：1->2->3->4->5，假设a/b的值为r
如果r等于0，不删除任何节点；
如果r在区间（0,1/5]上，删除节点1；
如果r在区间（1/5,2/5]上，删除节点2；
如果r在区间（2/5,3/5]上，删除节点3；
如果r在区间（3/5,4/5]上，删除节点4；
如果r在区间（4/5,1]上，删除节点5；
如果r大于1，不删除任何节点。

## 4.反转单向和双向链表
## 题目：
分别实现反转单向链表和反转双向链表的函数
## 要求：
如果链表长度为N，时间复杂度要为O(N)，额外空间复杂度要求为O(1)

## 5.反转部分单向链表
### 题目：
给定一个单向链表的头节点head，以及两个整数from和to，在单向链表上第from个节点到第to个节点进行反转
例如：
1->2->3->4->5->null, from=2, to=4
调整结果为：1->4->3->2->5
再如：
1->2->3->null，from=1,to=3
3->2->1->null
### 要求：
1.如果链表长度为N，时间复杂度要求为O(N)，额外空间复杂度要求为O(1)
2.如果不满足1<=from<=to<=N，则不用调整

## 6.环形单链表的约瑟夫问题
### 题目：
据说著名的犹太历史学家Josephus有过以下故事：在罗马人占领乔塔帕特后，39个犹太人与Josephus及他的朋友躲到一个洞中，39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀的方式
41个人排成一个圆圈，由第1个人开始报数，报数到3的自杀，然后再由下一个人重新报1，报到3的人再自杀，这样依次下去，直到剩下最后一个人，那个人可以自由选择自己的命运，这就是著名的约瑟夫问题、现在
请用单向环形链表描述该结构并呈现整个自杀过程

输入：一个环形单向链表的头节点head和报数的值m
返回：最后生存下来的节点，且这个节点自己组成环形单向链表，其他节点都删掉。

进阶：
如果链表节点数为N，想在时间复杂度为O(N)时完成原问题的要求，该怎样实现？

## 7.判断一个链表是否为回文结构
### 题目
给定一个链表的头节点head，请判断该链表是否为回文结构
例如：
1->2->1，返回true
1->2->2->1，返回true
15->6->15，返回true
1->2->3，返回false

进阶：
如果链表长度为N，时间复杂度达到O(N)，额外空间复杂度达到O(1)

## 8.将单向链表按某值划分成左边小，中间相等，右边大的形式
### 题目
给定一个单向链表的头节点head，节点的值类型是整型，再给定一个整数pivot，实现一个调整链表的函数，将链表调整为左部分都是值小于pivot的节点，
中间部分都是值等于pivot的节点，右部分都是值大于pivot的节点，除这个要求外，对调整后的节点顺序没有更多要求

例如：  链表 9 ->0 ->4 ->5 ->1，pivot=3
调整后链表可以是1 ->0 ->4 ->9 ->5，也可以是0 ->1 ->9 ->5 ->4.总之，满足左部分都是小于3的节点，中间部分都是等于3的节点，右部分都是大于3的节点即可。
对某部分内部的节点顺序不做要求

进阶：
在原问题的要求之上再增加如下两个要求：
 在左、中、右三个部分的内部也做顺序要求，要求每部分里的节点从左到右的顺序与原链表中节点的先后次序一致。
 
例如：链表9 ->0 ->4 ->5 ->1，pivot = 3.调整后的链表是0 ->1 ->9 ->4 ->5，在满足原问题要求的同时，左部分节点从左到右为0、1。在原链表中也是先出现0，后出现1；
中间部分在本例中为空，不在讨论；右部分节点从左到右为9、4、5。在原链表中也是先出现9，然后出现4，最后出现5
 如果链表长为N，时间复杂度请达到O(N)，额外空间复杂度请达到O(1)

## 9.复制含有随机指针节点的链表
### 题目：
一种特殊的链表节点描述如下:
    
    public class Node{
        public int value;
        public Node next;
        public Node rand;
        
        public Node(int data){
            this.value = value;
        }
    }
   Node 类中的value是节点值，next指针和正常单链表中next指针的意义一样，都指向下一个节点，rand指针是Node类中新增的指针，这个指针可能指向
   链表中的任意一个节点，也可能指向null
   给定一个由Node节点类型组成的无环单链表的头节点head，请实现一个函数完成这个链表中所有结构的复制，并返回复制的新链表的头节点。
   例如：链表 1 ->2 ->3 -> null，假设1的rand指针指向3,2的rand指针指向null，3的rand的指针指向1.复制后的链表应该也是这种结构，
   比如  1' ->2' ->3' -> null，1'的rand指针指向3'，2'的rand的指针指向null，3'的rand指针指向1'，最后返回1'
   
进阶：不使用额外的数据结构，只用有限几个变量，且在时间复杂度为O(N)内完成原问题要实现的函数
   
 ## 10.两个单链表生成相加链表
 ### 题目：
 假设链表中每个节点的值都在0~9之间，那么链表整体就可以代表一个整体
 例如：9->3->7，可以代表整数937
 给定两个这种链表的头节点head1和head2，请生成代表两个整数相加值的结果链表
 例如：链表1为9->3->7，链表2为6->2，最后生成新的结果链表为1->0->0->0
 
 ## 11.两个单链表相交的一系列问题
 ### 题目：
 在题目中，单链表可能有环，也可能无环。给定两个单链表的头节点head1和head2，这两个链表可能相交，也可能不想交。请实现一个函数，如果
 两个链表相交，请返回相交的第一个节点；如果不相交，返回null即可
 
 ### 要求：
 如果链表1的长度为N，链表2的长度为M，时间复杂度请达到O(N+M)，额外空间复杂度为O(1)
 
 ## 12.将单链表的每个K节点之间逆序
 
### 题目：
给定一个单链表的头节点head，实现一个调整单链表的函数，使得每K个节点之间逆序，如果最后不够K个节点一组，则不调整最后几个节点

例如：
链表： 1 ->2 ->3 ->4 ->5 ->6 ->7 ->8 ->null，K=3
调整为：3 ->2 ->1 ->6 ->5 ->4 ->7 ->8 ->null。其中7、8不调整，因为不够一组

## 13.删除无序单链表中值重复出现的节点
### 题目：
给定一个无序单链表的头节点head，删除其中值重复出现的节点
例如：1->2->3->3->4->4->2->1->1->null，删除值重复的节点之后为 1->2->3->4->null
### 要求：
请按照以下要求实现两种方式
方法1：如果链表长度为N，时间复杂度达到O(N)
方法2：额外空间复杂度为O(1)

## 14.在单链表中删除指定值的节点
## 题目：
给定一个链表的头节点head和一个整数num，请实现函数将值为num的节点全部删除
例如：链表为1->2->3->4->null，num=3，链表调整后为1->2->4->null

## 15.将搜索二叉树转换成双向链表

对二叉树的节点来说，有本身的值域，有指向左孩子和右孩子的两个指针；对双向链表的节点来说，有本身的值域，有指向上一个节点和下一个节点
的指针。在结构上，两种结构有相似性，现在有一颗搜索二叉树，请将其转换成一个有序的双向链表

例如：节点定义为
    
    public class Node{
        public int value;
        public Node left;
        public Node right;
        public Node(int data){
            this.value = data;
        }
    }
    
## 16. 单链表的选择排序
### 题目：
给定一个无序单链表的头节点head，实现单链表的选择排序
### 要求：
额外空间复杂度为O(1)
    
## 17.一种怪异的节点删除方式
### 题目：
链表节点值类型为int型，给定一个链表中的节点node，但不给定整个链表的头节点。如何在链表中删除node？请实现这个函数，并分析
这么会出现哪些问题
### 要求：
时间复杂度为O(1)

## 18.向有序的环形单链表中插入新节点
### 题目：
一个环形单链表从头节点head开始不降序，同时最后由最后的节点指回头节点，给定这样一个环形单链表的头节点head和一个整数num，请生成
节点值为num的新节点，并插入到这个环形链表中，保证调整后的链表依然有序

## 19.合并两个有序的单链表
### 题目：
给定两个有序单链表的头节点head1和head2，请合并两个有序链表，合并后的链表依然有序，并返回合并后链表的头节点

例如：
   0 ->2 ->3 ->7 ->null
   1 ->3 ->5 ->7 ->9 ->null
   合并后的链表为：0 ->1 ->2 ->3 ->3 ->5 ->7 ->7 ->9 ->null
  
## 20.按照左右半区的方式重新组合单链表
### 题目：
给定一个单链表的头部节点head，链表长度为N，如果N为偶数，那么前N/2个节点算做左半区，后N/2个节点算作右半区；如果N为奇数，那么前N/2
个节点算作左半区，后N/2+1节点算做右半区。左半区从左到右依次记为L1 ->L2 ->....，右半区从左到右一次记为R1 ->R2 ->...，请将单链表调整为
L1 ->R1 ->L2 ->R2 ->...的形式

例如：
1 ->null，调整为1 ->null
1 -> 2-> null，调整为1 ->null
1 -> 2 -> 3 -> null，调整为1 -> 2 -> 3 -> null
1 -> 2 -> 3 -> 4 -> null，调整为1 -> 3 -> 2 -> 4 -> null
1 -> 2 -> 3 -> 4 -> 5 -> null，调整为1 -> 3 -> 2 -> 4 -> 5 -> null
1 -> 2 -> 3 -> 4 -> 5 -> 6 -> null，调整为1 -> 4 -> 2 -> 5 -> 3 -> 6 -> null